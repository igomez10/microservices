package user

import (
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/base64"
	"net/http"
	"socialapp/internal/converter"
	"socialapp/pkg/db"
	"socialapp/socialappapi/openapi"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
)

// implements the UserServicer interface
// s *UserApiService openapi.UserApiServicer
type UserApiService struct {
	DB     db.Querier
	DBConn db.DBTX
}

const DEFAULT_ROLE_NAME = "administrator"

func (s *UserApiService) CreateUser(ctx context.Context, user openapi.CreateUserRequest) (openapi.ImplResponse, error) {
	// validate we dont have a user with the same username that is not deleted
	if _, err := s.DB.GetUserByUsername(ctx, s.DBConn, user.Username); err == nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Username already exists")
		return openapi.Response(http.StatusConflict, nil), nil
	}

	// validate we dont have a user with the same email that is not deleted
	if _, err := s.DB.GetUserByEmail(ctx, s.DBConn, user.Email); err == nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Email already exists")
		return openapi.Response(http.StatusConflict, nil), nil
	}

	// generate a random salt
	saltUUID, err := uuid.NewRandom()
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error generating random string for salt")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}
	salt := base64.StdEncoding.EncodeToString([]byte(saltUUID.String()))

	hashedPasswordBase64 := EncryptPassword(user.Password, salt)
	//generate random email token confirmation
	// generate a random salt
	emailTokenUUID, err := uuid.NewRandom()
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error generating random string for salt")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}
	emailToken := base64.StdEncoding.EncodeToString([]byte(emailTokenUUID.String()))

	// create the user with an autogenerated password that already expired
	params := db.CreateUserParams{
		Username:       user.Username,
		FirstName:      user.FirstName,
		LastName:       user.LastName,
		Email:          user.Email,
		HashedPassword: hashedPasswordBase64,
		EmailToken:     emailToken,
		Salt:           salt,
		EmailVerifiedAt: sql.NullTime{ // We will assume every email is confirmed for now
			Time:  time.Now(),
			Valid: true,
		},
	}

	createdUser, err := s.DB.CreateUser(ctx, s.DBConn, params)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error creating user")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}

	createdUserID, err := createdUser.LastInsertId()
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting created user id")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	// attach "user" role to new user

	// get the role id for "user"
	role, err := s.DB.GetRoleByName(ctx, s.DBConn, DEFAULT_ROLE_NAME)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting role id for user")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error getting role id for user",
			},
		}, nil

	}

	// attach the role to the user
	params2 := db.CreateUserToRoleParams{
		UserID: createdUserID,
		RoleID: role.ID,
	}
	if _, err := s.DB.CreateUserToRole(ctx, s.DBConn, params2); err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Str("username", user.Username).
			Str("default_role", DEFAULT_ROLE_NAME).
			Msg("Error attaching role to user")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error attaching default role to user",
			},
		}, nil
	}

	// get user from db
	dbUser, err := s.DB.GetUserByID(ctx, s.DBConn, createdUserID)
	if err != nil {
		log.Error()
	}

	apiUser := converter.FromDBUserToAPIUser(dbUser)

	return openapi.Response(http.StatusOK, apiUser), nil
}

func EncryptPassword(plaintextPassword string, salt string) string {
	saltedPassword := plaintextPassword + salt
	hashedPassword := sha256.Sum256([]byte(saltedPassword))
	hashedPasswordBase64 := base64.StdEncoding.EncodeToString(hashedPassword[:])
	return hashedPasswordBase64
}

// DeleteUser - Deletes a particular user
func (s *UserApiService) DeleteUser(ctx context.Context, username string) (openapi.ImplResponse, error) {
	if err := s.DB.DeleteUserByUsername(ctx, s.DBConn, username); err != nil {
		log.Error().Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error deleting user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error deleting user",
			},
		}, nil
	}

	return openapi.Response(http.StatusOK, nil), nil
}

// GetUserByUsername - Get a particular user by username
func (s *UserApiService) GetUserByUsername(ctx context.Context, username string) (openapi.ImplResponse, error) {
	dbUser, err := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting user",
			},
		}, nil
	}

	dbRoles, err := s.DB.GetUserRoles(ctx, s.DBConn, dbUser.ID)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user roles")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting user roles",
			},
		}, nil
	}

	apiUser := converter.FromDBUserToAPIUser(dbUser)
	for _, dbR := range dbRoles {
		apiRole := converter.FromDBRoleToAPIRole(dbR)
		apiUser.Roles = append(apiUser.Roles, apiRole)
	}

	return openapi.Response(http.StatusOK, apiUser), nil
}

// GetUserComments - Gets all comments for a user
func (s *UserApiService) GetUserComments(ctx context.Context, username string, limit int32, offset int32) (openapi.ImplResponse, error) {
	limit = limit % 100
	if limit == 0 {
		limit = 100
	}
	commnet, err := s.DB.GetUserComments(ctx, s.DBConn, db.GetUserCommentsParams{
		Username: username,
		Limit:    limit,
		Offset:   offset,
	})
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user comments")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting user comments",
			},
		}, nil
	}

	return openapi.Response(http.StatusOK, commnet), nil
}

// ListUsers - Returns all the users
func (s *UserApiService) ListUsers(ctx context.Context, limit, offset int32) (openapi.ImplResponse, error) {
	limit = limit % 20
	if limit == 0 {
		limit = 20
	}
	dbUsers, err := s.DB.ListUsers(ctx, s.DBConn, db.ListUsersParams{
		Limit:  limit,
		Offset: offset,
	})
	if err != nil {
		log.Error().
			Stack().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error listing users")

		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error listing users",
			},
		}, nil
	}

	apiUsers := make([]openapi.User, len(dbUsers))
	for i := range dbUsers {
		apiUsers[i] = converter.FromDBUserToAPIUser(dbUsers[i])
	}

	return openapi.Response(http.StatusOK, apiUsers), nil
}

func (s *UserApiService) UpdateUser(ctx context.Context, existingUsername string, newUserData openapi.User) (openapi.ImplResponse, error) {
	// get the user to update
	existingUser, err := s.DB.GetUserByUsername(ctx, s.DBConn, existingUsername)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting user",
			},
		}, nil
	}

	if newUserData.Username != "" && newUserData.Username != existingUser.Username {
		// validate we dont have a user with the same username that is not deleted
		noCaseUsername := strings.ToLower(newUserData.Username)
		if _, err := s.DB.GetUserByUsername(ctx, s.DBConn, noCaseUsername); err == nil {
			log.Error().
				Err(err).
				Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
				Msg("Username already exists")

			return openapi.ImplResponse{
				Code: http.StatusConflict,
				Body: openapi.Error{
					Code:    http.StatusConflict,
					Message: "Username already exists",
				},
			}, nil
		}
		existingUser.Username = newUserData.Username
	}

	if newUserData.Email != "" && newUserData.Email != existingUser.Email {
		// validate we dont have a user with the same email that is not deleted
		noCaseEmail := strings.ToLower(newUserData.Email)
		if _, err := s.DB.GetUserByEmail(ctx, s.DBConn, noCaseEmail); err == nil {
			log.Error().
				Err(err).
				Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
				Msg("Email already exists")
			return openapi.ImplResponse{
				Code: http.StatusConflict,
				Body: openapi.Error{
					Code:    http.StatusConflict,
					Message: "Email already exists",
				},
			}, nil
		}
		existingUser.Email = newUserData.Email
	}

	if newUserData.FirstName != "" {
		existingUser.FirstName = newUserData.FirstName
	}
	if newUserData.LastName != "" {
		existingUser.LastName = newUserData.LastName
	}

	params := db.UpdateUserByUsernameParams{
		OldUsername: existingUsername,
		NewUsername: newUserData.Username,
		FirstName:   newUserData.FirstName,
		LastName:    newUserData.LastName,
		Email:       newUserData.Email,
	}

	log.Debug().Msgf("UpdateUserByUsernameParams: \n%+v\n", params)
	uUser, err := s.DB.UpdateUserByUsername(ctx, s.DBConn, params)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error updating user")

		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error updating user",
			},
		}, nil
	}

	return openapi.Response(http.StatusOK, uUser), nil
}

func (s *UserApiService) FollowUser(ctx context.Context, followedUsername string, followerUsername string) (openapi.ImplResponse, error) {
	// validate the user exists
	followedUser, errGetFollowed := s.DB.GetUserByUsername(ctx, s.DBConn, followedUsername)
	if errGetFollowed != nil {
		log.Error().
			Err(errGetFollowed).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting followed user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting followed user",
			},
		}, nil
	}

	followerUser, errGetFollower := s.DB.GetUserByUsername(ctx, s.DBConn, followerUsername)
	if errGetFollower != nil {
		log.Error().
			Err(errGetFollower).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting follower user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting follower user",
			},
		}, nil
	}

	//  add follow connection
	err := s.DB.FollowUser(ctx, s.DBConn, db.FollowUserParams{
		FollowerID: followerUser.ID,
		FollowedID: followedUser.ID,
	})
	if err != nil {
		log.Error().
			Err(errGetFollower).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error following user")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error following user",
			},
		}, nil
	}

	return openapi.Response(http.StatusOK, nil), nil
}

func (s *UserApiService) GetUserFollowers(ctx context.Context, username string) (openapi.ImplResponse, error) {
	// validate the user exists
	user, errGetUser := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if errGetUser != nil {
		log.Error().
			Err(errGetUser).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting user",
			},
		}, nil
	}

	dbFollowers, err := s.DB.GetFollowers(ctx, s.DBConn, user.ID)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Int64("user_id", user.ID).
			Msg("Error getting followers")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error getting followers",
			},
		}, nil
	}

	apiFollowers := make([]openapi.User, len(dbFollowers))
	for i := range dbFollowers {
		apiFollowers[i] = converter.FromDBUserToAPIUser(dbFollowers[i])
	}

	return openapi.Response(http.StatusOK, apiFollowers), nil
}

func (s *UserApiService) UnfollowUser(ctx context.Context, followedUsername string, followerUsername string) (openapi.ImplResponse, error) {
	// validate the user exists
	followedUser, errGetFollowed := s.DB.GetUserByUsername(ctx, s.DBConn, followedUsername)
	if errGetFollowed != nil {
		log.Error().
			Err(errGetFollowed).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting followed user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting followed user",
			},
		}, nil
	}

	followerUser, errGetFollower := s.DB.GetUserByUsername(ctx, s.DBConn, followerUsername)
	if errGetFollower != nil {
		log.Error().
			Err(errGetFollower).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting follower user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting follower user",
			},
		}, nil
	}

	//  add follow connection
	err := s.DB.UnfollowUser(ctx, s.DBConn, db.UnfollowUserParams{
		FollowerID: followerUser.ID,
		FollowedID: followedUser.ID,
	})
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error unfollowing user")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error unfollowing user",
			},
		}, nil
	}

	return openapi.Response(http.StatusOK, nil), nil
}

func (s *UserApiService) GetFollowingUsers(ctx context.Context, username string) (openapi.ImplResponse, error) {
	// validate the user exists
	user, errGetUser := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if errGetUser != nil {
		log.Error().
			Err(errGetUser).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting user",
			},
		}, nil
	}

	dbFollowing, err := s.DB.GetFollowedUsers(ctx, s.DBConn, user.ID)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting followed users")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting followed users",
			},
		}, nil
	}

	apiFollowing := make([]openapi.User, len(dbFollowing))
	for i := range dbFollowing {
		apiFollowing[i] = converter.FromDBUserToAPIUser(dbFollowing[i])
	}

	return openapi.Response(http.StatusOK, apiFollowing), nil
}

func (s *UserApiService) ChangePassword(ctx context.Context, req openapi.ChangePasswordRequest) (openapi.ImplResponse, error) {
	// get user from request context
	username, ok := ctx.Value("username").(string)
	if !ok {
		log.Error().
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user from context")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error getting user from context",
			},
		}, nil
	}

	// validate the user exists
	user, errGetUser := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if errGetUser != nil {
		log.Error().
			Err(errGetUser).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.ImplResponse{
			Code: http.StatusNotFound,
			Body: openapi.Error{
				Code:    http.StatusNotFound,
				Message: "Error getting user",
			},
		}, nil
	}

	// validate the old password is correct
	encryptedHashedOldPassword := EncryptPassword(req.OldPassword, user.Salt)
	if encryptedHashedOldPassword != user.HashedPassword {
		log.Error().
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error validating old password")

		return openapi.ImplResponse{
			Code: http.StatusUnauthorized,
			Body: openapi.Error{
				Code:    http.StatusUnauthorized,
				Message: "Error validating old password",
			},
		}, nil
	}

	// hash the new password but keep the same salt
	encryptedHashedNewPassword := EncryptPassword(req.NewPassword, user.Salt)

	// update the password
	_, err := s.DB.UpdateUser(ctx, s.DBConn, db.UpdateUserParams{
		ID:                      user.ID,
		HashedPassword:          string(encryptedHashedNewPassword),
		Username:                user.Username,
		FirstName:               user.FirstName,
		LastName:                user.LastName,
		Email:                   user.Email,
		Salt:                    user.Salt,
		HashedPasswordExpiresAt: user.HashedPasswordExpiresAt,
		EmailToken:              user.EmailToken,
		EmailVerifiedAt:         user.EmailVerifiedAt,
	})
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error updating password")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error updating password",
			},
		}, nil
	}

	// invalidate existing tokens
	if err = s.DB.DeleteAllTokensForUser(ctx, s.DBConn, user.ID); err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error deleting existing tokens")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: openapi.Error{
				Code:    http.StatusInternalServerError,
				Message: "Error deleting existing tokens",
			},
		}, nil
	}

	apiUser := converter.FromDBUserToAPIUser(user)
	return openapi.Response(http.StatusOK, apiUser), nil
}

func (s *UserApiService) ResetPassword(_ context.Context, _ openapi.ResetPasswordRequest) (openapi.ImplResponse, error) {
	panic("not implemented") // TODO: Implement
}
