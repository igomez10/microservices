package user

import (
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/base64"
	"net/http"
	"socialapp/pkg/db"
	"socialapp/socialappapi/openapi"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
)

// implements the UserServicer interface
// s *UserApiService openapi.UserApiServicer
type UserApiService struct {
	DB     db.Querier
	DBConn db.DBTX
}

func (s *UserApiService) CreateUser(ctx context.Context, user openapi.CreateUserRequest) (openapi.ImplResponse, error) {
	// validate we dont have a user with the same username that is not deleted
	if _, err := s.DB.GetUserByUsername(ctx, s.DBConn, user.Username); err == nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Username already exists")
		return openapi.Response(http.StatusConflict, nil), nil
	}

	// validate we dont have a user with the same email that is not deleted
	if _, err := s.DB.GetUserByEmail(ctx, s.DBConn, user.Email); err == nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Email already exists")
		return openapi.Response(http.StatusConflict, nil), nil
	}

	// generate a random salt
	saltUUID, err := uuid.NewRandom()
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error generating random string for salt")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}
	salt := base64.StdEncoding.EncodeToString([]byte(saltUUID.String()))

	hashedPasswordBase64 := EncryptPassword(user.Password, salt)
	//generate random email token confirmation
	// generate a random salt
	emailTokenUUID, err := uuid.NewRandom()
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error generating random string for salt")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}
	emailToken := base64.StdEncoding.EncodeToString([]byte(emailTokenUUID.String()))

	// create the user with an autogenerated password that already expired
	params := db.CreateUserParams{
		Username:       user.Username,
		FirstName:      user.FirstName,
		LastName:       user.LastName,
		Email:          user.Email,
		HashedPassword: hashedPasswordBase64,
		EmailToken:     emailToken,
		Salt:           salt,
		EmailVerifiedAt: sql.NullTime{ // We will assume every email is confirmed for now
			Time:  time.Now(),
			Valid: true,
		},
	}

	createdUser, err := s.DB.CreateUser(ctx, s.DBConn, params)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error creating user")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}

	createdUserID, err := createdUser.LastInsertId()
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting created user id")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	// get user from db
	dbUser, err := s.DB.GetUserByID(ctx, s.DBConn, createdUserID)
	if err != nil {
		log.Error()
	}

	apiUser := FromDBUserToOpenAPIUser(dbUser)

	return openapi.Response(http.StatusOK, apiUser), nil
}

func EncryptPassword(plaintextPassword string, salt string) string {
	saltedPassword := plaintextPassword + salt
	hashedPassword := sha256.Sum256([]byte(saltedPassword))
	hashedPasswordBase64 := base64.StdEncoding.EncodeToString(hashedPassword[:])
	return hashedPasswordBase64
}

// DeleteUser - Deletes a particular user
func (s *UserApiService) DeleteUser(ctx context.Context, username string) (openapi.ImplResponse, error) {
	if err := s.DB.DeleteUserByUsername(ctx, s.DBConn, username); err != nil {
		log.Error().Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error deleting user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	return openapi.Response(http.StatusOK, nil), nil
}

// GetUserByUsername - Get a particular user by username
func (s *UserApiService) GetUserByUsername(ctx context.Context, username string) (openapi.ImplResponse, error) {
	dbUser, err := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	apiUser := FromDBUserToOpenAPIUser(dbUser)

	return openapi.Response(http.StatusOK, apiUser), nil
}

// GetUserComments - Gets all comments for a user
func (s *UserApiService) GetUserComments(ctx context.Context, username string, limit int32, offset int32) (openapi.ImplResponse, error) {
	limit = limit % 100
	if limit == 0 {
		limit = 100
	}
	commnet, err := s.DB.GetUserComments(ctx, s.DBConn, db.GetUserCommentsParams{
		Username: username,
		Limit:    limit,
		Offset:   offset,
	})
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user comments")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	return openapi.Response(http.StatusOK, commnet), nil
}

// ListUsers - Returns all the users
func (s *UserApiService) ListUsers(ctx context.Context, limit, offset int32) (openapi.ImplResponse, error) {
	limit = limit % 20
	if limit == 0 {
		limit = 20
	}
	dbUsers, err := s.DB.ListUsers(ctx, s.DBConn, db.ListUsersParams{
		Limit:  limit,
		Offset: offset,
	})
	if err != nil {
		log.Error().
			Stack().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error listing users")

		return openapi.Response(http.StatusNotFound, nil), nil
	}

	apiUsers := make([]openapi.User, len(dbUsers))
	for i := range dbUsers {
		apiUsers[i] = FromDBUserToOpenAPIUser(dbUsers[i])
	}

	return openapi.Response(http.StatusOK, apiUsers), nil
}

func (s *UserApiService) UpdateUser(ctx context.Context, existingUsername string, newUserData openapi.User) (openapi.ImplResponse, error) {
	// get the user to update
	existingUser, err := s.DB.GetUserByUsername(ctx, s.DBConn, existingUsername)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	if newUserData.Username != "" && newUserData.Username != existingUser.Username {
		// validate we dont have a user with the same username that is not deleted
		noCaseUsername := strings.ToLower(newUserData.Username)
		if _, err := s.DB.GetUserByUsername(ctx, s.DBConn, noCaseUsername); err == nil {
			log.Error().
				Err(err).
				Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
				Msg("Username already exists")

			return openapi.Response(http.StatusConflict, nil), nil
		}
		existingUser.Username = newUserData.Username
	}

	if newUserData.Email != "" && newUserData.Email != existingUser.Email {
		// validate we dont have a user with the same email that is not deleted
		noCaseEmail := strings.ToLower(newUserData.Email)
		if _, err := s.DB.GetUserByEmail(ctx, s.DBConn, noCaseEmail); err == nil {
			log.Error().
				Err(err).
				Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
				Msg("Email already exists")
			return openapi.Response(http.StatusConflict, nil), nil
		}
		existingUser.Email = newUserData.Email
	}

	if newUserData.FirstName != "" {
		existingUser.FirstName = newUserData.FirstName
	}
	if newUserData.LastName != "" {
		existingUser.LastName = newUserData.LastName
	}

	params := db.UpdateUserByUsernameParams{
		OldUsername: existingUsername,
		NewUsername: newUserData.Username,
		FirstName:   newUserData.FirstName,
		LastName:    newUserData.LastName,
		Email:       newUserData.Email,
	}

	log.Debug().Msgf("UpdateUserByUsernameParams: \n%+v\n", params)
	uUser, err := s.DB.UpdateUserByUsername(ctx, s.DBConn, params)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error updating user")

		return openapi.Response(http.StatusNotFound, nil), nil
	}

	return openapi.Response(http.StatusOK, uUser), nil
}

func (s *UserApiService) FollowUser(ctx context.Context, followedUsername string, followerUsername string) (openapi.ImplResponse, error) {
	// validate the user exists
	followedUser, errGetFollowed := s.DB.GetUserByUsername(ctx, s.DBConn, followedUsername)
	if errGetFollowed != nil {
		log.Error().
			Err(errGetFollowed).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting followed user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	followerUser, errGetFollower := s.DB.GetUserByUsername(ctx, s.DBConn, followerUsername)
	if errGetFollower != nil {
		log.Error().
			Err(errGetFollower).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting follower user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	//  add follow connection
	err := s.DB.FollowUser(ctx, s.DBConn, db.FollowUserParams{
		FollowerID: followerUser.ID,
		FollowedID: followedUser.ID,
	})
	if err != nil {
		log.Error().
			Err(errGetFollower).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error following user")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}

	return openapi.Response(http.StatusOK, nil), nil
}

func (s *UserApiService) GetUserFollowers(ctx context.Context, username string) (openapi.ImplResponse, error) {
	// validate the user exists
	user, errGetUser := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if errGetUser != nil {
		log.Error().
			Err(errGetUser).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	dbFollowers, err := s.DB.GetFollowers(ctx, s.DBConn, user.ID)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting followers")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	apiFollowers := make([]openapi.User, len(dbFollowers))
	for i := range dbFollowers {
		apiFollowers[i] = FromDBUserToOpenAPIUser(dbFollowers[i])
	}

	return openapi.Response(http.StatusOK, apiFollowers), nil
}

func (s *UserApiService) UnfollowUser(ctx context.Context, followedUsername string, followerUsername string) (openapi.ImplResponse, error) {
	// validate the user exists
	followedUser, errGetFollowed := s.DB.GetUserByUsername(ctx, s.DBConn, followedUsername)
	if errGetFollowed != nil {
		log.Error().
			Err(errGetFollowed).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting followed user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	followerUser, errGetFollower := s.DB.GetUserByUsername(ctx, s.DBConn, followerUsername)
	if errGetFollower != nil {
		log.Error().
			Err(errGetFollower).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting follower user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	//  add follow connection
	err := s.DB.UnfollowUser(ctx, s.DBConn, db.UnfollowUserParams{
		FollowerID: followerUser.ID,
		FollowedID: followedUser.ID,
	})
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error unfollowing user")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}

	return openapi.Response(http.StatusOK, nil), nil
}

func (s *UserApiService) GetFollowingUsers(ctx context.Context, username string) (openapi.ImplResponse, error) {
	// validate the user exists
	user, errGetUser := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if errGetUser != nil {
		log.Error().
			Err(errGetUser).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	dbFollowing, err := s.DB.GetFollowedUsers(ctx, s.DBConn, user.ID)
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting followed users")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	apiFollowing := make([]openapi.User, len(dbFollowing))
	for i := range dbFollowing {
		apiFollowing[i] = FromDBUserToOpenAPIUser(dbFollowing[i])
	}

	return openapi.Response(http.StatusOK, apiFollowing), nil
}

func FromDBUserToOpenAPIUser(u db.User) openapi.User {
	apiUser := openapi.User{
		Username:  u.Username,
		FirstName: u.FirstName,
		LastName:  u.LastName,
		Email:     u.Email,
		CreatedAt: u.CreatedAt,
	}

	return apiUser
}

func (s *UserApiService) ChangePassword(ctx context.Context, req openapi.ChangePasswordRequest) (openapi.ImplResponse, error) {
	// get user from request context
	username, ok := ctx.Value("username").(string)
	if !ok {
		log.Error().
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user from context")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}

	// validate the user exists
	user, errGetUser := s.DB.GetUserByUsername(ctx, s.DBConn, username)
	if errGetUser != nil {
		log.Error().
			Err(errGetUser).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error getting user")
		return openapi.Response(http.StatusNotFound, nil), nil
	}

	// validate the old password is correct
	//
	encryptedHashedOldPassword := EncryptPassword(req.OldPassword, user.Salt)
	if encryptedHashedOldPassword != user.HashedPassword {
		log.Error().
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error validating old password")
		return openapi.Response(http.StatusUnauthorized, nil), nil
	}

	// hash the new password
	encryptedHashedNewPassword := EncryptPassword(req.NewPassword, user.Salt)

	// update the password
	_, err := s.DB.UpdateUser(ctx, s.DBConn, db.UpdateUserParams{
		ID:                      user.ID,
		HashedPassword:          string(encryptedHashedNewPassword),
		Username:                user.Username,
		FirstName:               user.FirstName,
		LastName:                user.LastName,
		Email:                   user.Email,
		Salt:                    user.Salt,
		HashedPasswordExpiresAt: user.HashedPasswordExpiresAt,
		EmailToken:              user.EmailToken,
		EmailVerifiedAt:         user.EmailVerifiedAt,
	})
	if err != nil {
		log.Error().
			Err(err).
			Str("X-Request-ID", ctx.Value("X-Request-ID").(string)).
			Msg("Error updating password")
		return openapi.Response(http.StatusInternalServerError, nil), nil
	}

	return openapi.Response(http.StatusOK, nil), nil
}

func (s *UserApiService) ResetPassword(_ context.Context, _ openapi.ResetPasswordRequest) (openapi.ImplResponse, error) {
	panic("not implemented") // TODO: Implement
}
