package authentication

import (
	"context"
	"net/http"
	"socialapp/internal/encryption"
	"socialapp/pkg/db"
	"socialapp/socialappapi/openapi"

	"github.com/rs/zerolog/log"
)

// s *AuthenticationService openapi.AuthenticationApiServicer
type AuthenticationService struct {
	DB     db.Querier
	DBConn db.DBTX
}

func (s *AuthenticationService) GetAccessToken(ctx context.Context) (openapi.ImplResponse, error) {
	username := ctx.Value("username")
	if username == nil {
		return openapi.ImplResponse{
			Code: http.StatusUnauthorized,
			Body: openapi.Error{
				Code:    http.StatusUnauthorized,
				Message: "Unauthorized",
			},
		}, nil
	}

	usr, err := s.DB.GetUserByUsername(ctx, s.DBConn, username.(string))
	if err != nil {
		log.Error().Err(err).Msg("Failed to get user")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: []byte(err.Error()),
		}, nil
	}

	privKey, pubKey := encryption.GenerateKeyPair(2048)
	pubKeyString := string(encryption.PublicKeyToBytes(pubKey))
	privKeyString := string(encryption.PrivateKeyToBytes(privKey))

	_, err = s.DB.CreateCredential(ctx, s.DBConn, db.CreateCredentialParams{
		UserID:      usr.ID,
		PublicKey:   pubKeyString,
		Description: "Generated by socialapp",
		Name:        "socialapp",
	})
	if err != nil {
		log.Error().Err(err).Msg("Failed to create credential")
		return openapi.ImplResponse{
			Code: http.StatusInternalServerError,
			Body: []byte(err.Error()),
		}, nil
	}

	return openapi.ImplResponse{
		Code: http.StatusInternalServerError,
		Body: privKeyString,
	}, nil
}
